#                选择排序
# 1.始终从未排序的序列中找到最小的放到最前面
# 2.将第一个元素先作为最小值，用第一个元素和后面的元素依次比较
# 3.首次碰见比第一个元素更小的元素就记录这个“较小元素”的位置
# 4.继续比较如果碰见比“较小元素”还更小的元素，就将记录的“较小元素”的位置信息，替换成“更小元素”的位置信息
# 5.直到比较完整个序列，最小的元素位置信息就被记录下来了
# 6.交换第一个元素和最小元素的位置，序列的头部就变成了最小的元素
# 7.再将第二个元素先作为序列剩余元素的最小元素，和剩下的元素重复上述步骤进行比较
# 8.将第二小的元素找到，并和第二个元素进行交换
# 9.多次重复上述步骤n-1次，即可得到升序序列
# 10.最优复杂度：O(n^2)    最坏复杂度：O(n^2)    稳定性：不稳定


def select_sort(alist):
    """选择排序"""
    n = len(alist)
    for j in range(n-1):
        # 列表的长度为n,从0开始计算一共为n-1个数。
        # 最后一趟只剩最后一个数，一定是最大的不用比较。
        # 所以只需要比较n-2次。
        min_index = j
        for i in range(j+1, n):
            if alist[min_index] > alist[i]:
                min_index = i
        alist[j], alist[min_index] = alist[min_index], alist[j]


if __name__ == '__main__':
    li = [56, 26, 77, 6, 54, 38, 96, 43, 99]
    print(*li)
    select_sort(li)
    print(*li)