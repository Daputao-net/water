#                   冒泡排序
# 1.比较相邻的元素，如果第一个比第二个大（升序），就交换他们两个
# 2.对每一对相邻的元素做同样的工作，从开始到结尾的最后一对
#   这步做完后，最后的元素会是最大的数
# 3.针对所有的元素重复以上的步骤，除了最后一个
# 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
# 5.稳定性：数值相同的元素在排序中不交换位置为稳定反之为不稳定
# 6.最优复杂度：O(n)   最坏复杂度：O(n^2)   稳定性：稳定
def bubble_sort(alist):
    """冒泡排序"""
    n = len(alist)
    for j in range(n-1):
        # range(5)的取值范围是从0~4此处要取到n-2（下标从0开始）所以
        # 此处的值为n-1
        count = 0
        # 如果进行了交换count加一，如果内层循环中发现某次交换一次都没有发生
        # 即count == 0,则说明列表已经是有序的了，直接退出外层循环，优化了程序
        for i in range(n-1-j):
            if alist[i] > alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]
                count += 1
        if count == 0:
            break


if __name__ == '__main__':
    li = [56, 88, 12, 62, 54, 79, 32, 11, 96]
    print(*li)
    bubble_sort(li)
    print(*li)
